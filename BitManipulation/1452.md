暴力解法很容易被想到，针对每一个人，我们查看是否在所有人中被另外一个人 "彻底包住"，如果是这样的话不加入结果。否则加入结果。
```
class Solution {
public:
    vector<int> peopleIndexes(vector<vector<string>>& favoriteCompanies) {
        int m = favoriteCompanies.size();
        vector<int> res;
        for (int i = 0; i < m; i++) {
            int flag = 1;
            for (int j = 0; j < m; j++) {
                if (i == j) continue;
                // if i is a subset of j, continue, else add to result
                if (isSubSet(favoriteCompanies, i, j)) {
                    flag = 0;
                    break;
                }
            }
            if (flag) res.push_back(i);
        }
        return res;
    }
    
    bool isSubSet(vector<vector<string>>& c, int i, int j) {
        unordered_set<string> Set(c[j].begin(), c[j].end());
        for (auto comp : c[i]) {
            if (Set.find(comp) == Set.end()) return false;
        }
        return true;
    }
};

// 2 is not in res, since "included" in 0
// 3 is not in res, since "included" in 0, 1
```

本题还有另外一种解法，考虑到本题目的数据范围 `1 <= n <= 100`，也就是最多有 100 个，则用一个 BitMask 表示一家公司被多少人喜欢。

在 `example 1` 中，`google` 在 `[0, 1, 2, 3]` 中都出现了，则 `comp[google] = 01111`

我们创造这个数据结构的意义是，我们可以用 BitMask 取 `and` 的方法快速淘汰掉不喜欢某公司的一批人

在 `example 1` 中，`leetcode` 仅仅在 `[0]` 中出现，则 `comp[leetcode] = 00001`

在 `example 1` 中，`facebook` 仅仅在 `[0, 2]` 中出现，则 `comp[facebook] = 00101`

这个时候我们可以看到，如果一个人即喜欢 `google`，又喜欢 `leetcode` 和 `facebook`，那么 BitMask 表示一定为 `00001`

这就是 `example 1` 中第一个人的状态，因为 BitMask 中只有一个 `1`，则表示只有一个人满足此条件，就应该将其加入到结果中。

如果有两个人即喜欢 `google`，又喜欢 `leetcode` 和 `facebook`，那么 BitMask 中就会有两个 `1`，就不应该将此人加入到结果中。

```
class Solution {
public:
    vector<int> peopleIndexes(vector<vector<string>>& favoriteCompanies) {
        unordered_map<string, bitset<100>> comp2ppl;
        int m = favoriteCompanies.size();
        for (int i = 0; i < m; i++) {
            for (string comp : favoriteCompanies[i]) {
                comp2ppl[comp][i] = 1;
            }
        }
        
        vector<int> res;
        for (int i = 0; i < m; i++) {
            bitset<100> bs;
            bs.set();
            for (string comp : favoriteCompanies[i]) {
                bs &= comp2ppl[comp];
            }
            if (bs.count() == 1) {
                res.push_back(i);
            }
        }
        return res;
    }
};
```
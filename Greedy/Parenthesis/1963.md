本题的直觉是，如果能够已经把配对完毕的括号消除，针对没有配对括号进行 Swap ，所用的次数可能会少一些。

按照模板，我们可以写出如下代码，计算没有匹配的左侧括号数

- 当 `count++` 时，表明没有匹配的左括号数增加了
- 当 `count--` 时，表明发现了右侧括号与其匹配，没有匹配的左括号数减少了
- 当 `count < 0`，表明发现的右侧括号太多了，所以需要手动增加左侧括号，
  即执行 `unmatched++`，手动增加完左侧括号后，需要把没有匹配的左括号数置为0

```
int count = 0
for (char c : s) {
    if (c == '(') count++;
    if (c == ')') count--;
    if (count < 0) {
        unmatched++;
        count = 0
    }
}
```

由于本题是 even length，所以表明没有匹配的左括号数和右括号数是相同的，
所以我们必然有以下的 Pattern

```
][
]][[
]]][[[
]]]][[[[
```

由此我们可以总结规律

```
][ -> 1
]][[ -> swap(0, 3) -> [][] -> 1
]]][[[ -> swap(1, 4) -> ][][][ -> swap(0, 5) -> [[][]] -> 2
]]]][[[[ -> swap(2, 5) -> ]][][][[ -> swap(0, 7) -> [][][][] -> 2
```

所以可以总结出规律为，只需要 `(unmatched + 1) / 2` 次交换就可以达成目标了。

本题的最大不同点在于允许同种元素之间重复 2 次，但是不允许同种元素出现 3 次。那么很显然，为了满足条件。我们会尽量把出现次数多的放在一起 2 次。

虽然有这种策略，我们不能直接按照 aab 或者 bba 的策略追加字符串，因为这种策略追加出来的字符串不能保证在 a ＋ b 次追加后，a 和 b 的出现次数符合要求。

那么应该怎么办呢？我们只需要按照 abab / baba 的策略追加字符串，如果 b 比 a 多，而当 a  用完后，我们再将剩下来的 b 加到每一个 ba 之前就可以了。同理，如果 a 比 b 多，而当 b 用完后，我们再将剩下来的 a 加到每一个 ab 之前就可以了。

因为题中已经给了 a 和 b 的个数，那么我们可不可以预先就在出现次数多的字符前多添加呢？当然可以，针对出现次数少的，我们每次就维持原样，只添加 1 个。针对出现次数多的，我们需要追加

```
min(1 + times1 - times2, 2)
```

个字符，其中 1 指的是每次我们最少追加 1 个字符。times1 是高频字符的出现次数 (堆中第一个弹出的)，times2 是较低频字符的出现次数 (堆中第二个弹出的)，我们针对高频字符，很显然需要多追加这 2 个字符频次的相差值来弥补，但是为了满足条件，最高我们不能追加超过 2 次。

最后注意边界情况，pq 的大小为 1 时，我们不能再弹出 2 个元素，因为本题保证有解，此时直接将这些元素追加到 res 后即可。


本题的基本题意是，从数组的左右两侧拿数字，最多拿 K 次，然后求得分最高的方法。

此题乍看左右双指针可解，也就是从左侧和右侧拿数字，哪个大就拿哪个，然后移动指针。

但是拿 `example 1` 举例，`cardPoints = [1,2,3,4,5,6,1], k = 3`，这里的最优解很显然是 `[1, 6, 5]`，
也就是先拿右侧的 `1`。如果拿了左侧的 `1`，那下一轮只能拿右侧仍然存在的 `1` 和左侧的 `2` 去选择，这就已经不是最优解了。

在这种情况下，双指针在两个值相等时，是无法判断应该拿哪个值的，那么我们能不能再新开一个指针？继续对上方例子中的 `2` 和 `6` 进行比较呢？

其实到现在，双指针的策略就应该在脑中被彻底被打消了，考虑下方这个 case，是双指针完全照顾不到的
```
[1, 1, 1, 1, 99999, 100, 100, 100, 100, 100]
k = 5
```

很显然上方的最优解是 `[1, 1, 1, 1, 99999]` 而不是连续的 5 个 100。

正确的想法实际上是这样的，考虑到我们无论如何都是要从数组的左右两侧拿数字，如果 K = 3，那么我们无非有以下几种策略
1. 要左侧的 3 个值
2. 要左侧的 2 个值，要右侧的 1 个值
3. 要左侧的 1 个值，要右侧的 2 个值
4. 要右侧的 3 个值

对于任意的 `K`，我们都只有 `K + 1` 种选择。

那么我们的正确做法就是枚举 `K + 1` 种情况，如果左侧我们一共要 `left` 个值，那么我们就得出右侧一共要 `K - left` 个值。

```
for (int left = 0; left < k + 1; left++) {
    int right = k - left;
}
```

怎样得到左侧要 `i` 个值后的收益呢？我们可以选择从 `cardPoints[0]` 到 `cardPoints[i]` 将这些值累加起来，当然这时，我们也许已经意识到，
前缀和的使用可以快速帮助我们解决这个问题。

最终代码

```
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int m = cardPoints.size();
        vector<int> presum(m + 1, 0);
        for (int i = 1; i <= m; i++) {
            presum[i] = presum[i - 1] + cardPoints[i - 1];
        }
        
        int sum = 0;
        for (int left = 0; left < k + 1; left++) {
            int right = k - left;
            sum = max(sum, (presum[left] - presum[0]) + (presum[m] - presum[m - right]));
        }      
        return sum;
    }
};
```

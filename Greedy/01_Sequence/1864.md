对于 '101010' 这种题目，根据 1888 题目的经验，我们首先思考交换后的字符串可能会是什么样子。

首先，我们很容易想到不可能的情况，就是 1 的数量 和 0 的数量如果相差 2 及以上，那么是不可能通过交换获得 0 / 1 交换的序列的，则返回 -1

在排除上方的情况后，交换后的字符串 s1 的结果一共有下方四种情况，就是 
- a. 以 0 为开头，并且有单数个0
- b. 以 1 为开头，并且有单数个1
- c. 以 0 为开头，并且有双数个0 （同时也有双数个 1）
- d. 以 1 为开头，并且有双数个1 （同时也有双数个 0）

1. 首先考虑 a 和 b 的情况

```
01010
10101
```

在启示 2 中，我们已经得到原来字符串 s 的数量情况，如果 0 的数量大于 1 的数量
那么我们很显然需要考虑情况 a，否则考虑情况 b

我们使用 index i 遍历字符串 a 或者 b，并且开启变量值 `count`。
在遍历过程中，`a[i]` 或者 `b[i]` 与原来的字符串 `s[i]` 进行比较，如果不相同，则 `count` 计数增加，最后返回 `count / 2`
(本题求最少的交换次数，两次 `s[i]` 和 `a[i]` 或者 `b[i]` 的不同，可以合并为一次交换) 就是答案。

2. 再考虑 c 和 d 的情况

```
010101
101010
```

不难看出，由于 0 和 1 的数量都是偶数，所以 c 经过交换可以得到 d，d 经过交换可以得到 c。 所以本质上 c 和 d 是同一种字符串。

这就意味着我们可以同时遍历 c 和 d，并且开启变量值 `count0` 或者 `count1`。
在遍历过程中，`c[i]` 或者 `b[i]` 与原来的字符串 `d[i]` 进行比较，如果 `c[i]` 和 `s[i]` 不相同，则 `count0` 计数增加。如果 `d[i]` 和 `s[i]` 不相同，则 `count1` 计数增加。

最后的结果为:

```
min(count0 / 2, count1 / 2);
```

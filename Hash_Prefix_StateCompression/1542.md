本题可以看作是 1371 和 1915 题目的组合，并且把题目加上了一层包装。

选取一串 Substring，将不同位置的字符进行交换，让其满足回文串的性质

其实等同于确保在一个 Substring 中，所有的数字都出现偶数次，只允许一个数字出现奇数次(或者不出现)。

我们仍然使用同样的方法，在第一次遇到 state 时，记录其出现的最早的位置。

```
dp[state] = min(dp[state], i);
```

当重复遇到该状态的时候，只需要执行 `i - dp[state]` 就可以获取满足条件的字符串长度，在这些长度中取得最大值。

不要忘记，本题还允许最多有 1 个数字出现偶数次，
所以我们需要遍历 state，将每一位逐个取反获得 oddState，并且把 `i - dp[oddState]` 考虑在结果范围内。



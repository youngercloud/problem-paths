本题和 1371 的思想基本相同，不同点有如下

- 1371 为了获取最长的字符串长度，需要记录最早出现的下标，本题为了求这样的 Substring 的个数，需要记录的是某个状态具体出现的次数。
- 本题的边界条件是 `dp[0] = 1`，即空字符串出现了 1 次。
- 本题允许在 Substring 中有一个出现次数为奇数的字母，那就意味着我们在更新结果后，还需要将各字母的状态位反转，并且记录到符合条件的出现次数中。代码如下:

```
res += dp[state];
for (int j = 0; j < 10; j++) {
    int oddstate = state ^ (1 << j);
    res += dp[oddstate];
}
```


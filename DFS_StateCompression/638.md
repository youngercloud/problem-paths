针对第 i 项状态，如果不能用 0 或者 1 表示 非满足 或者 满足条件，可以用真实数字的二进制，然后将其放到每一项进行表示

例如:
    第 3 种物品要买 8 个
```    
needs[2] = 8;
state += needs[2] << (2 * 4);
```

因为我们针对每项物品最多买 10 件，而长度为 4 的二进制比特序列可以表示数字 0 - 15 , 所以这里要乘 4

在当前状态中获得第 3 种物品要买 8 个的状态

```    
(state >> (2 * 4)) % 16
```
- 因为要观察第 3 种物品的状态，需要去除状态中的第 1 件和第 2 件物品，每件物品的个数可以用 4 个比特位表示，所以需要右移动 (2 * 4) 位。
- 因为要观察第 3 种物品的状态，需要去除状态中的第 4 / 5 / 6 件物品，所以直接取余 16 即可

State 样例

第 1 件物品买 4 个，第 2 件物品买 6 个，第 3 件物品买 9 个
```
1001 0110 0011 
```

我们解题的方法不仅可以时，从 0 件物品慢慢买，最后买到targetState。
还可以将 targetState 看做我们的需求，从 targetState 买到 0，买到 0 就证明我们没需求了。


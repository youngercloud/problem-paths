1. 如何为字符串设计字典树？
针对字符设计字典树，我们可以开一个 26 长度的数组
针对 0 / 1 比特设计字典树，我们可以开一个长度为 2 的数组。

为字符串设计字典树，我们可以开一个 Map，Map 的 Key 为 字符串本身，Value 为 TrieNode 对象。

2. 此题的本质就是 652.Find-Duplicate-Subtrees
我们给字典树的每个节点的子树计算 Hash。对应同一个 Hash Key 的子树都是重复的。我们在第二次遍历整棵字典树的时候，遇重复就终止并返回即可。

3. 第一次遍历字典树的目的是找出子树重复出现的次数。本题与 652 的区别是，判断两棵子树 A 与 B 是否相同的定义，与子树的根节点本身无关。只要 A 的子树与 B 的子树相同，那么 A 与 B 就是相同的。所以我们计算 Hash 的时候，不需要考虑当前根节点，而是考虑所有子节点的 Hash 以及子节点的值。

```
string key = "";
for (auto p : cur->children) {
      key += to_string(getId(p.second)) + "#" + p.first + "#";
}
```

同 652 的做法相同，我们可以使用一个 ID 来表示 Key 来增加其效率。

4. 第二次遍历字典树的目的是构造结果，我们可以在第一次遍历中记录节点和 Key 的对应关系。在这次遍历中，如果发现某个节点的 key 出现过了两次以上，就停止向下递归。
```
        string k = node2key[cur];
        if (k != "" && key2cnt[k] >= 2) return;
        if (cur->val != "/") {
            path.push_back(cur->val);
            ans.push_back(path);
        }
        for (auto p : cur->children) dfs(p.second, path);
        if (cur->val != "/") path.pop_back();
```

5. 这里要注意 k != "" 的情况，因为我们在计算 Key 的时候只考虑了节点的子节点，所以针对字典树所有的叶子节点 (没有子节点)，他们的 Key 值都为 ""。那么很显然，因为一个树的叶子节点很多，所以 key2cnt[""] 的值必然会 >= 2，所以所有的叶子节点就被忽略了。
    那么我们规避这种情况的方法是，在检查 key2cnt[""] 时，先检查下当前节点是不是叶子节点，因为只有叶子节点的 Key 是 ""，如果当前节点不是叶子节点，再进行出现次数的判断。


如何判断树中存在 2 个子树是完全相同的 ？ 比较简单的想法是选择树中的每一个节点作为一棵子树的根节点，然后遍历整棵子树。如果发现这颗子树的遍历结果曾经得到过，那证明我们找到了 2 颗相同的子树。

如何发现我们遍历的子树的遍历结果是之前被得到过的呢？我们可以想到用 HashSet 存储我们每一颗遍历的子树。而在 HashSet 里存储树的方法，则可以是将这颗子树序列化为字符串，然后将字符串加入到 HashSet 中。

但是，遍历整颗树，选择每一颗节点作为子树的根节点的时间复杂度是 O (N) ，然后序列化整个子树的复杂度也是 O (N)，按照这种策略很明显会TLE。

那我们怎么进行优化呢?

因为树的序列化操作是一种递归操作，所以我们不必选择每个树中的节点单独作为根节点去进行序列化。我们只需要选择根节点去进行序列化，然后在递归过程中将结果存入进 HashSet 就可以了

还有一个问题需要考虑，如果一棵树很大，那么其序列化后的字符串可能会很长，导致这个字符串和其他出现过的字符串比对时，产生的开销会很大。在这种情况下，我们将字符串序列当作一个 key，并且将 key 转化为一个 ID，然后维护 key 和 ID 的映射，这样的效率就高很多了。那么，我们就将整个序列化过程都包装在 getId() 方法中。
        
例如，对于根节点为 node 的子树，我们定义它的字符串序列 (即 key) 为:

```
string key = to_string(node->val) + "#" + to_string(getId(node->left)) + "#" + to_string(getId(node->right))
```

其中 key 就是根节点为 node 的子树的序列化结果，getId 就是左子树（或者右子树）序列化结果的 ID。显然 node 本身的值和其左右子节点的 ID 的所结合成的字符串长度，就会比整棵树序列化的字符串长度短很多。

    我们建立 2 个 HashMap 分别为 key2Id 以及 key2Count，分别代表一个字符串序列所对应的 ID 以及出现次数。

如果上方代码生成的 key 在 key2Id 中已经出现过，那么说明当前的子树就是一个duplicate subtree，就要加入到结果中。如果是第一次在 key2Id 中出现，我们就给这个 key 映射一个新的ID，一般就令 key 对应的 ID 值为

```
key2Id[key] = key2Id.size() + 1;
```

这个结果也就是 getId(node) 的返回值。


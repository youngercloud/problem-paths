本题的切入点在于，需要构造出一个图结构，所有的人都作为图节点，并且指向其偏向坐在一起的人。
由于所有的人都存在偏好的人，就意味着所有的节点都有出度。

此时我们再想一下，既然所有的节点都有出度，那么肯定至少有一个节点的出边会指向这个图中的其他节点，
也就意味着，这个图结构必定是存在至少具有 2 个节点的环的。

```
1     2<--
 \   /   |
  \ /    |
   v     |
   3 -----
```
在上图中，`1` 和 `2` 节点指向节点 `3`，由于 `3` 必须有出度，
所以其要么需要指向 `1`，要么需要指向 `2`，无论指向哪一个，都无法避免成环。


要知道，两个节点的环上的每一个节点都是都至少具有一个入度和一个出度。
当然，我们很快就会意识到，这个入度和出度都是针对相同节点的。
例如上图 `2, 3` 

`2` 的入度是 `3`, `2` 的出度也是指向 `3`，所以目前 `2` 和 `3` 只有对方一个邻居。
而一个人是在圆桌上吃饭，是可以具有两个邻居的，并且这两个邻居当然也可以都是自己喜欢的。

所以针对这二元环上的两个点，如果这两个点上有多个边，除了必须选择用于成环的一条边，
我们还可以选择另外一条边，并且这条边应该是沿着走下去，相对所有其他边中，所访问节点数是最多的。

```
    1     2<--
     \   /   |
      \ /    |
       v     |
       3 -----
      / \
     4  7
    /
   5
  /
 6 
```


二元环的两个节点，再加上接入二元环的最长边上的节点数，在上图中为 `2 + 3`，就是答案之一

但是要知道，很明显二元环是一种特殊情况。本题的第二个例子实际上构成的就是三元环。

二元环能够允许另外一条边接入，是因为二元环的入度出度都是指向同一节点。但是三元环就不一样了，例如本题的第二个例子

```
      0
     / ^
    /   \
   /     \
  v       \ 
 1-------->2
```


此刻 `1` 虽然也是只有一个入度和一个出度，但是却已经有了两个邻居 `0` 和 `2`，
那么就意味着，我们不能再尝试在三元环上增添一个新的 “接入” 边了。
如果强制接入，那么在接入点处，会出现一个出度，两个入度的情况，
然而在桌子上是不可能出现一个人有三个邻居的。

但是我们还是可以保证，这个三元环上本身所有的节点都是满足条件的。
不仅仅是三元环，四元环，还是五元环，环本身的的大小也成为了备选答案之一。

```
class Solution {
    vector<int> g[100005];
    int inDegree[100005];
    int depth[100005];
public:
    int maximumInvitations(vector<int>& favourite) {
        int m = favourite.size();
        for (int i = 0; i < m; i++) {
            g[i].push_back(favourite[i]);
            inDegree[favourite[i]]++;
            depth[i] = 1;
        }
        
        queue<int> q;
        for (int i = 0; i < m; i++) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        
        while (!q.empty()) {
            auto n = q.front();
            q.pop();
            
            for (int conn : g[n]) {
                inDegree[conn]--;
                if (inDegree[conn] == 0) {
                    q.push(conn);
                }
                depth[conn] = depth[n] + 1;
            }
        }
        
        int r1 = 0;
        int r2 = 0;
        for (int i = 0; i < m; i++) {
            if (inDegree[i] == 0) {
                continue;
            }
            int j = i;
            int cnt = 0;
            while (inDegree[j]) {
                cnt++;
                inDegree[j]--;
                j = favourite[j];
            } 
            if (cnt >= 3) {
                r1 = max(r1, cnt);
            }
            if (cnt == 2) {
                r2 += depth[i] + depth[favourite[i]];
            }
        }
        return max(r1, r2);
    }
};

```
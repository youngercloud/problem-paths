本题目的难度分在 2800 以上， 主要是本题的优化空间很大，所以会导致常规的解法 TLE

针对每一个数字，我们可以想象其是一个区间，而分割数字的方式可以用例子来表示

假设我们当前分割数字的长度为 3，那么我们可以做如下分割

一定可以分割，因为前一个数字长度为 1 ，比 3 要短
```
[X][X X X]
```

一定可以分割，因为前一个数字长度为 2 ，比 3 要短
```
[X X][X X X]
```

不一定可以分割，需要查看前一个数字和当前数字的大小关系
```
[X X X][X X X]
```

在这种情况下，一个区间型 dp 的思路就出来了，那么我们可以设计状态
```
dp[i][j]: i 为当前下标，j 为当前分割数字的长度，值为到目前为止共有多少种分割方法
```

所以我们可以写出下列代码:
```
for (int i = 0; i < m; i++) {
    for (int len = 1; len <= i + 1; len++) {
        
    }
}
```

然后，我们现在做的可以是确定前一个数字的长度了，很显然，为了前一个数字比当前数字小，
我们需要确定前一个数字的最大长度。

其长度不能超过当前数字的长度。
```
[X X X X][X X X]
很显然这不符合题干中规定的递增条件
```

其长度不能超过当前数字的开始索引位置。
```
[X][X X X]  
 0  1 2 3
// 已经确定 i = 3， 当前分割数字的长度为 3，
则当前数字的开始索引位置为 1，推导前面数字的时候，长度也不能超过 1
```

当两者长度相等时，需要如果前一个数字比当前数字大，说明其违反了相邻数字递增的条件。
```
[1 2 3 5][1 2 3 4]
```

综合以上，并且加入
- 题干中开头不允许为 `'0'` 的条件
- 以及分割长度为 1 数字的边界条件

则我们可以写出下列代码
```
for (int i = 0; i < m; i++) {
    for (int len = 1; len <= i + 1; len++) {
        int start = i - len + 1;
        int premaxlen = min(start, len);
        if (num[start] == '0') continue;
        if (len == i + 1) dp[i][len] = 1;
        if (premaxlen == len && 
            num.substr(start - premaxlen, premaxlen) >
            num.substr(start, premaxlen)) {
            premaxlen--;
        }
        for (int plen = 1; plen <= premaxlen; plen++) {
           
        }
    }
}
```

现在，我们可以更新我们的 DP 值了，更新 DP 值的操作也比较简单，当前分割数字的方法总数，
就是所有前一个数字在不同长度下，分割前一个数字方法数的总和

```
s = start
[ X  X  X ][ X  X  X  X ]
       s-i   s        i
dp[i][len] = dp[start - 1][1] + dp[start - 1][2] + dp[start - 1][3]
```

最后的结果就是在数字全部分割完毕后 `i = m`，最后一个数字在不同长度下取最大值
```
class Solution {
    long long mod = 1e9 + 7;    
public:
    int numberOfCombinations(string num) {
        int m = num.size();
        vector<vector<int>> dp(m, vector<int>(m + 1, 0));
        for (int i = 0; i < m; i++) {
            for (int len = 1; len <= i + 1; len++) {
                int start = i - len + 1;
                int premaxlen = min(start, len);
                if (num[start] == '0') continue;
                if (len == i + 1) dp[i][len] = 1;
                if (premaxlen == len && 
                    num.substr(start - premaxlen, premaxlen) >
                    num.substr(start, premaxlen)) {
                    premaxlen--;
                }
                for (int plen = 1; plen <= premaxlen; plen++) {
                    dp[i][len] = (dp[i][len] + dp[start - 1][plen]) % mod;
                }
            }
        }
        
        int sum = 0;
        for (int i = 1; i <= m; i++) {
            sum = (sum + dp[m - 1][i]) % mod;
        }
        return sum;
    }
};
```




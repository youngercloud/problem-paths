- Permutation - 全排列

例如: 123,132,213,231,312,321 在第一位选择完 1 个数后，第二位可以选择 (n - 1) 个数字，所以一共有 n! 个不同的排列。

- 从 n 中选 m 个数构造全排列
```
A(n, m) = n! / (n - m)!
```

- Circle Permutation - 圆排列

  圆排列的满足条件是，在一种圆排列中，相邻两数之间的顺序必须相同。 
  例如:
  - (123, 312, 231) 是一个圆排列，(312 由 123 右移得到)
  - (132, 213, 321) 是一个圆排列 
    
圆排列一共有 `n! / n` 即 `(n - 1)!` 个。这是因为，一个圆排列中所有元素的首元素不一样。 也就是说，就算首元素不一样，我们仍然把它算在同一个 "排列" 中。
  
然而，`n` 个数字中的任何一个都可能成为首元素，所以针对上方的 "全排列" 的个数计算方法而言，我们在这里忽略掉了首元素，那么个数就需要除以 `n`


- 从 `n` 中选 `m` 个数构造圆排列，能构造出多少个不同的圆排列
```
AC(n, m) = n! / (n - m)! / m
```

那么我们就可以使用 `dp` 来求解圆排列个数构造问题

设 `dp[i][j]`: 使用 i 个数字构造 j 个圆排列

情况1: 如果元素 i 是一个新的圆排列
```
dp[i - 1][j - 1]
```
情况2: 如果元素 i 加入了一个已有的圆排列，则将 i 插入现有的圆排列，并且有 i - 1 种插法（圆排列中共有 i - 1 个元素，圆中每两个元素之间都可以插入）
```
dp[i - 1][j] * (i - 1)
```
所以最终的状态方程为:
```
dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] * (i - 1)
```

即第一类斯特林数，表示将 n 个不同元素构成 m 个圆排列的数目。 

本题:

思考在 n 个数字中选择 k 个数，转换为思考将 n 个数字分成 k 个区间，每个区间最大的数则为 k 本身。

则有 `[k1 ...][k2 ....][k3....][k4....]` 且满足 `k1 < k2 < k3 < k4`。

仔细想一下，针对每一个区间而言，这个过程选择了一个数作为首元素 (最高的 stick)，然后摆放剩下的元素。

例如:
```
n = 10 k = 3
[3 1 2] [6 5 4] [10 8 9 7]
```

针对第一个区间而言，`3` 是首元素

然后可以摆放剩下的元素。
```
[3 1 2]
[3 2 1]
```

这恰好等价于用 (1, 2, 3) 这三个元素能够组成的 "圆排列" 的个数，所以本题也可以直接套用 "从 `n` 中选 `m` 个数构造圆排列" 的状态转移方程。

```
typedef long long LL;
class Solution {
    LL mod = 1e9 + 7;
    LL dp[1001][1001];
public:
    int rearrangeSticks(int n, int k) {
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * (i - 1)) % mod;
            }
        }
        return dp[n][k] % mod;
    }
};
```


顺便附赠计算 `C(n, k)` 结果的方法
```
long long C[1030][21];
long long mod = 1e9 + 7;
for (int i = (C[0][0] = 1); i < n; i++) {
    for (int j = (C[i][0] = 1); j < k; j++) {
        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
    }
}
```





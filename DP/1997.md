拿到这道题时，最简单的想法是准备一个指针来模拟整个过程，那么针对每个第一次 (奇数次) 走到的数字，我们都要回退到 `nextVisit[i]` 这个点再走第二次。
这样总体的时间复杂度粗略估计是是 `O(N^2)`，看看数据范围 `2 <= n <= 10^5`。这样的时间复杂度一定是会 TLE 的。

那么我们可以怎么想呢？我们发现，针对现在这个点 `i`，我们无非有 2 种情况
- 第一次走到 `i`，回退到之前的某个点 `nextVisit[i]`
- 第二次走到 `i`，继续往下走

使用 `dp[i]` 来表示我们当前走到点 `i` 需要的最少的步数，那我们可以推出状态转移方程
- 第一次走到 `i`，回退到之前的某个点 `nextVisit[i]`，那么需要重复走 `nextVisit[i]` 到 `i` 的这段路程，状态转移方程为

```
dp[i - 1] - dp[nextVisited[i - 1]] + 1
```

表示从 `i - 1` 点，如果不需要重新走的话，走到 `i` 需要走的步数是 `dp[i - 1] + 1`，
可惜我们是第一次走到 `i - 1` 点，则将方程改为上方的形式。

- 第二次走到 `i - 1` 点，不需要回退，直接往下走即可，状态转移方程为
```
dp[i - 1] + 1
```

最终的状态转移方程为
```
dp[i] = (dp[i - 1] + 1) + (dp[i - 1] - dp[nextVisited[i - 1]] + 1)
```

最终代码
```
int m = nextVisit.size();
vector<int> dp(m + 1, 0);
for (int i = 1; i < m; i++) {
    int j = nextVisit[i - 1];
    dp[i] = ((dp[i - 1] + 1) + (dp[i - 1] - dp[j] + 1 + mod)) % mod;
}
return dp[m - 1];
```
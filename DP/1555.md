我们令 `dp[0]` 表示截止到元素 i 的位置、以 0 结尾的子序列的个数。

注意，为了保证合法，这样的序列必须只包含 0 。 

同理我们令 `dp[1]` 表示截止到元素 i 的位置、以 1 结尾的子序列的个数，这样的子序列必须只有 0 与 1，且 0 都在 1 之前。

令 `dp[2]` 表示截止到元素 i 的位置、以 2 结尾的子序列的个数，这样的子序列必须只有 0 / 1 / 2 ，且依次出现。

我们发现，当 `nums[i] = 0` 的时候，对于 `dp[1]` 和 `dp[2]` 没有影响，因为我们无法使用这个 0 得任何新的 01 序列或者 012 序列。

但是对于已有的纯 0 序列，我们可以有两种操作：
1. 附加上这个位置上的 0 以构造出新的序列
2. 不附加维持原来的纯 0 序列。

这样 `dp[0]` 的种类其实就翻倍了，故经过这个位置后

```
dp[0] = dp[0] * 2
```

同理，当 `nums[i] = 1` 的时候，对于 `dp[0]` 和 `dp[2]` 没有影响。那么 01 序列的个数如何变化呢？同样两种操作：
1. 不附加这个 1，那么原来有多少 01 序列，现在仍然有多少 01 序列。
2. 附加这个 1，那么原来有多少纯 0 序列和 01 序列，都会因为添加了这个 1 成为了一个新的 01 序列。

```
dp[1] = dp[1] + (dp[0] + dp[1])
```

同理，当 `nums[i] = 2` 的时候，对于 `dp[0]` 和 `dp[1]` 没有影响。那么 012 序列的个数如何变化呢？同样两种操作：
1. 不附加这个 2，那么原来有多少 012 序列，现在仍然有多少 012 序列
2. 附加这个 2，那么原来有多少 01 序列和 012 序列，都会因为添加了这个 2 成为了一个新的 012 序列。

```
dp[2] = dp[2] + (dp[1] + dp[2])
```

本题的难点是初始状态的设计。我们可以想象，如果我们把三个量都初始化为 0 的话，那么所有的结果都依然为 0 。 所有我们需要给一个初始的“动量”，就是令 `dp[0] = 1` 。

但是这样会出现一个问题，`dp[0]` 所表示的纯 0 序列的个数，其实包括了不附加任何 0 (遇见 0 我们就不要) 的情况，而这时当我们构造 01 序列时候，
却要求纯 0 序列的部分不能为空 ( 为空了就是纯 1 序列了，纯 1 序列是没有意义的 )。

所以对于 `dp[1]` 需要改动为 `dp[1] = dp[1] + (dp[0] - 1) + dp[1]` 。 注意，对于 `dp[1]` 和 `dp[2]` 的表达式，
我们都保证了 1 和 2 的个数都不为零（1 的个数为 0 那就是纯 0 序列了），故我们没有类似的担心。经过修改后，`dp[1]` 和 `dp[2]` 都能准确地表示合法的 01 序列和 012 序列的个数。


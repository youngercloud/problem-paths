基本思想还是维护一个单调递增的栈，但是在本题的情况下有 2 点需要注意
1. 遇到已经用过的字符 `c` 就跳过，因为当前栈里已经有 `c` 了，如果舍弃栈里的 `c`，那么必将导致栈中的大字符前移，使得栈中的单词字典序会变大。
所以肯定是不要当前的 `c`。
   
2. 如果当前字符 `c` 会打破栈的递增，那么我们需要看看 `c` 在后续的 `s` 中还能不能再出现。
   - 如果可以，那我们就愿意把这个打破栈递增的字符 “往后拖一拖”
   - 如果 `s` 中没有剩余的 `c`，不退栈了，因为要保证至少每个字符出现过一次
   
```
class Solution {
public:
    string removeDuplicateLetters(string s) {
        int m = s.size();
        vector<int> count(26, 0);
        unordered_set<char> Set;
        for (auto c : s) count[c - 'a']++;
        
        string res = "";
        for (int i = 0; i < m; i++) {
            count[s[i] - 'a']--;
            if (Set.find(s[i]) != Set.end()) continue;
            while(!res.empty() && res.back() > s[i] && count[res.back() - 'a'] > 0) {
                Set.erase(res.back());
                res.pop_back();
            }
            res.push_back(s[i]);
            Set.insert(s[i]);
        }
        return res;
    }
};
```
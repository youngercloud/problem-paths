本题解法为带权的二分图匹配，可以使用 KM 算法去解，也可以用基于状态压缩的 DP 或者 Djikstra。该题目解法和 1879 一模一样，类似的题目还有 1066

不带权的二分图匹配可以用匈牙利算法解决，如题目 1820
- 切记，因为本题求最大值，所以在使用 Dijkstra 的时候不可以使用大顶堆，因为 Dijkstra 只适用于最短路径，不适用于最长路径。具体的做法是，将问题转化为求出 student[i] 和 mentor[j] 匹配后，最少的丢失分数。

因为一共有 n 道题目，`student[i]` 和 `mentor[j]` 匹配后，一共得到的分数是 camp，那么两个人丢失的分数是

```
n - camp
```

所以，我们应该加入小顶堆的是

```
pq.push(sum + n - camp, newState);
```


最后，当所有学生都被匹配后，答案即为满分 ( 所有 student 的所有答案都和 mentor 的答案匹配) 再减去最少的丢失分数。

```
if (m == __builtin_popcount(state)) return m * n - sum;
```


### Dijkstra
因为 `nums2` 是可变的，那就意味着 `nums2[index]` 中，只要在 index 的值在 `nums2` 数组大小的有效范围内，那么 index 值具体是多少，实际上是无所谓的。换言之，一个不变的 index 可以匹配 `nums2` 中的任意数值

所以我们考虑可以设计状态 state ，state 的定义是表示 `nums2` 的数值有哪些被匹配到了，1 表示和 `nums1` 上的数字匹配完毕，0 表示没有和 `nums1` 上的数字匹配。例如:

```
10010 
```

表示 `nums2[1]` 以及 `nums2[4]` 和 `nums1` 上的数值匹配了
 
我们使用 C++ 的 API:

```
__builtin_popcount(state)
```

获得总共和 `nums1` 匹配完毕的 `nums2` 的数的个数，在上方的例子中，该代码运行的结果为 2 (一共有 `nums2[1]` 和 `nums2[4]` 总共 2 个被匹配了)

由于上文提到，相同的 index 可以匹配任意 `nums2` 上的数字，并且 `__builtin_popcount(state)` 可以保证值的范围在 `nums2` 数组的有效范围内（不可能总共匹配的个数比 `nums2` 的个数还多），所以我们选取 `nums2` 上的具体的和 `nums1` 匹配的数的策略为

```
nums2[__builtin_popcount(state)]
```

接下来，只需要遍历 `nums1` 上的数字，再加上一轮的结果就是答案

```
nums1[i] ^ nums2[__builtin_popcount(state)] + sum
```

### DP
- 第一层循环，使用 index i 遍历所有的 `nums1`，因为 `nums2` 是可变的，所以自然的想法是为前 i 个 `nums1` 数字匹配 `nums2` 中任意的数字。
- 第二层循环，按照 Dijkstra 中设计 state 的思路，用 state 表明 `nums2` 的数字是否有和 `nums1` 匹配完毕。
- 第三层循环，使用 index j 遍历所有 `nums2` 的数字，按照 Dijkstra 中设计 state 的思路，如果 `(state >> j) & 1` 的结果为 1，表明这个 state 用到了 `nums2` 中的第 j 个数字，那么可以推断出上一轮的状态为

```
dp_prev[state - (1 << j)]
```

也就是还没有使用 `nums2` 中第 j 个数字时的 state 的情况

加上这一轮的结果 `nums1[i] ^ nums2[j]` 就是答案

```
dp[state] = dp_prev[state - (1 << j)] + nums[i] + nums[j];
```

3. Gosper Hack: 给定一个数值 k ，该算法可以帮助遍历所有拥有 k 个比特值为 1 的state，避免遍历所有的 state 可以显著的提高效率。

本题和 1879 题以及 1947 题解法一模一样，但是 Dijkstra 中 state 应该是自行车被匹配了数量，主要的原因是:

如果我们选择使用 state 表示 worker 被匹配的数量，并且使用 (state & i) & 1 查看第 i 个 worker 是否被匹配过，如果没有被匹配过则更新，那么表达式变成了:

```
m = __builtin_popcount(state);
sum + abs(bikes[m][0] - workers[i][0]) + abs(bikes[m][1] - workers[i][1]);
```

上方的这个表达式实际上是有问题的，因为 worker 数量比自行车少，那就会少考虑很多的状态。
例如: 可能有 10 个自行车，但是 m 的最大值 (即所有人被匹配) 最多只有 6 个，所以 bikes 的 7 / 8 / 9 / 10 就永远取不到了。

选择自行车作为被匹配的数量，我们仍然可以用 `__builtin_popcount()` 这个内置函数去查看自行车的个数，如果被匹配的自行车数量够人数了，就证明所有人都匹配完了。

但是如果是用 DP 去解，那 state 就要设为 worker 被匹配到了几个。
举例来说，如果我们有 5 个 worker，那我们可以快速确定 `dp[11111]` 就是最终答案，并且可以直接 `return dp[11111]`。

但是如果是 state 是自行车被匹配的个数，因为自行车数量比 worker 多，如果我们有 5 个 worker，6 个自行车，那么 `dp[111110]`，`dp[111011]` 这些状态值中都有可能是答案，但是你却无法找到这个答案，因为你在这个过程中不知道哪些自行车被匹配了，而哪些没有。


